N = 3 class p8_board: def
__init__(self, board, x, y, h):
 self.board = board
 self.x = x
self.y = y self.h =
h row = [0, 0, -1, 1]
column = [-1, 1, 0, 0]
def is_valid(x, y):
 return 0 <= x < N and 0 <= y < N
def is_goal(board):
 goal = [[1,2,3],[4,5,6],[7,8,0]]
return board == goal def
manhattan(board):
 goal_pos = {
 1:(0,0), 2:(0,1), 3:(0,2),
 4:(1,0), 5:(1,1), 6:(1,2),
 7:(2,0), 8:(2,1)
 }
 distance = 0 for i
in range(N): for j
in range(N):
val = board[i][j]
if val != 0:
 gx, gy = goal_pos[val]
distance += abs(i-gx) + abs(j-gy)
return distance
def hill_climbing(start, x, y):
 current = p8_board(start, x, y, manhattan(start))
while True: if is_goal(current.board):
 print("Goal Found using Hill Climbing")
for r in current.board:
 print(r)
return neighbors
= [] for i in
range(4):
 new_x = current.x + row[i]
new_y = current.y + column[i] if
is_valid(new_x, new_y):
 new_board = [r[:] for r in current.board]
new_board[current.x][current.y], new_board[new_x][new_y] = \
new_board[new_x][new_y], new_board[current.x][current.y] h
= manhattan(new_board)
neighbors.append(p8_board(new_board, new_x, new_y, h)) best =
min(neighbors, key=lambda s: s.h) if best.h >= current.h:
 print("Stuck at Local Maximum")
 return
current = best
start_board = [
 [1,2,3],
 [4,5,6],
 [7,0,8]
]
hill_climbing(start_board, 2, 1)
